"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.componentCamelCase = exports.extractTokenInfo = exports.parsePropertyControls = exports.propControlsToType = exports.extractPropControlsUnsafe = exports.extractPropControlsSafe = exports.findRelativeLinks = exports.bundle = void 0;
const esbuild_1 = require("esbuild");
const url_1 = __importDefault(require("url"));
const async_sema_1 = require("async-sema");
const dprint_node_1 = __importDefault(require("dprint-node"));
const esbuild_plugin_polyfill_node_1 = require("esbuild-plugin-polyfill-node");
const framer_1 = require("./framer");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const child_process_1 = require("child_process");
const css_js_1 = require("./css.js");
const dedent_1 = __importDefault(require("dedent"));
const utils_js_1 = require("./utils.js");
const esbuild_2 = require("./esbuild");
function validateUrl(url) {
    try {
        const u = new URL(url);
    }
    catch (e) {
        throw new Error(`Invalid URL: ${url}`);
    }
}
function bundle(_a) {
    return __awaiter(this, arguments, void 0, function* ({ cwd: out = '', watch = false, components = {}, breakpoints = {}, signal = undefined, }) {
        out || (out = path_1.default.resolve(process.cwd(), 'example'));
        out = path_1.default.resolve(out);
        try {
            fs_1.default.mkdirSync(out, { recursive: true });
        }
        catch (e) { }
        const buildContext = yield (0, esbuild_1.context)({
            // entryPoints: {
            //     index: url,
            // },
            absWorkingDir: out,
            entryPoints: Object.keys(components).map((name) => {
                const url = components[name];
                validateUrl(url);
                return {
                    in: `virtual:${name}`,
                    out: name,
                };
            }),
            jsx: 'automatic',
            bundle: true,
            platform: 'browser',
            metafile: true,
            format: 'esm',
            minify: false,
            treeShaking: true,
            splitting: true,
            // splitting: true,
            logLevel: 'error',
            pure: ['addPropertyControls'],
            external: esbuild_2.externalPackages,
            plugins: [
                (0, esbuild_2.esbuildPluginBundleDependencies)({
                    signal,
                }),
                (0, esbuild_plugin_polyfill_node_1.polyfillNode)({}),
                {
                    name: 'virtual loader',
                    setup(build) {
                        build.onResolve({ filter: /^virtual:.*/ }, (args) => {
                            return {
                                path: args.path.replace(/^virtual:/, ''),
                                namespace: 'virtual',
                            };
                        });
                        build.onLoad({ filter: /.*/, namespace: 'virtual' }, (args) => __awaiter(this, void 0, void 0, function* () {
                            const name = args.path;
                            const url = components[name];
                            return {
                                contents: /** js */ `'use client'
                                import Component from '${yield (0, esbuild_2.resolveRedirect)({
                                    url,
                                    signal,
                                })}'
                                import { WithFramerBreakpoints } from 'unframer'
                                Component.Responsive = (props) => {
                                    return <WithFramerBreakpoints Component={Component} {...props} />
                                }
                                export default Component
                                `,
                                loader: 'jsx',
                            };
                        }));
                    },
                },
            ],
            write: false,
            // outfile: 'dist/example.js',
            outdir: out,
            // outfile: path.resolve(cwd, sourcefile),
        });
        function rebuild() {
            return __awaiter(this, void 0, void 0, function* () {
                const prevFiles = fs_1.default.readdirSync(out).map((x) => path_1.default.resolve(out, x));
                const result = yield buildContext.rebuild();
                for (let file of result.outputFiles) {
                    const resultPathAbs = path_1.default.resolve(out, file.path);
                    const existing = yield fs_1.default.promises
                        .readFile(file.path, 'utf-8')
                        .catch(() => null);
                    let codeNew = `// @ts-nocheck\n` +
                        `/* eslint-disable */\n` +
                        dprint_node_1.default.format(resultPathAbs, file.text, {
                            lineWidth: 140,
                            quoteStyle: 'alwaysSingle',
                            trailingCommas: 'always',
                            semiColons: 'always',
                        });
                    const lines = findRelativeLinks(codeNew);
                    if (lines.length) {
                        utils_js_1.logger.error(`found broken links for ${path_1.default.relative(out, file.path)}, don't use relative links in Framer components`);
                        lines.forEach((line) => {
                            utils_js_1.logger.error(`${path_1.default.resolve(out, file.path)}:${line + 1}`);
                        });
                    }
                    if (existing === codeNew) {
                        continue;
                    }
                    utils_js_1.logger.log(`writing`, path_1.default.relative(out, file.path));
                    fs_1.default.writeFileSync(resultPathAbs, codeNew, 'utf-8');
                }
                let allFonts = [];
                const sema = new async_sema_1.Sema(10);
                const packageJson = path_1.default.resolve(out, 'package.json');
                fs_1.default.writeFileSync(packageJson, JSON.stringify({ type: 'module' }), 'utf-8');
                try {
                    yield Promise.all(result.outputFiles.map((file) => __awaiter(this, void 0, void 0, function* () {
                        try {
                            yield sema.acquire();
                            const name = path_1.default
                                .basename(file.path)
                                .replace(/\.js$/, '');
                            const resultPathAbs = path_1.default.resolve(out, file.path);
                            if (!components[name]) {
                                return;
                            }
                            utils_js_1.logger.log(`extracting types for ${name}`);
                            const { propertyControls, fonts } = yield extractPropControlsUnsafe(resultPathAbs, name);
                            if (!propertyControls) {
                                utils_js_1.logger.log(`no property controls found for ${name}`);
                            }
                            allFonts.push(...(fonts || []).map((x) => (Object.assign(Object.assign({}, x), { fileName: path_1.default.basename(file.path) }))));
                            const types = propControlsToType(propertyControls, name);
                            // name = 'framer-' + name
                            // logger.log('name', name)
                            fs_1.default.writeFileSync(path_1.default.resolve(out, `${name}.d.ts`), types);
                        }
                        finally {
                            sema.release();
                        }
                    })));
                }
                finally {
                    fs_1.default.rmSync(packageJson);
                }
                const cssString = '/* This css file has all the necessary styles to run all your components */\n' +
                    (0, css_js_1.breakpointsStyles)(breakpoints) +
                    '\n\n' +
                    framer_1.combinedCSSRules
                        .map((x) => ((x === null || x === void 0 ? void 0 : x.startsWith('  ')) ? (0, dedent_1.default)(x) : x))
                        .join('\n') +
                    (0, css_js_1.getFontsStyles)(allFonts);
                fs_1.default.writeFileSync(path_1.default.resolve(out, 'styles.css'), cssString, 'utf-8');
                (0, css_js_1.logFontsUsage)(allFonts)
                    .split('\n')
                    .forEach((x) => utils_js_1.logger.log(x));
                const outFiles = result.outputFiles
                    .map((x) => path_1.default.resolve(out, x.path))
                    .concat([
                    path_1.default.resolve(out, 'meta.json'),
                    path_1.default.resolve(out, 'tokens.css'),
                    path_1.default.resolve(out, 'styles.css'),
                ])
                    .concat(result.outputFiles.map((x) => path_1.default.resolve(out, x.path.replace('.js', '.d.ts'))));
                const filesToDelete = prevFiles.filter((x) => !outFiles.includes(x));
                for (let file of filesToDelete) {
                    utils_js_1.logger.log('deleting', path_1.default.relative(out, file));
                    fs_1.default.rmSync(file);
                }
                fs_1.default.writeFileSync(path_1.default.resolve(out, 'meta.json'), JSON.stringify(result.metafile, null, 2), 'utf-8');
                if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
                    throw new Error('aborted');
                }
                // logger.log('result', result)
                if (watch) {
                    utils_js_1.logger.log('waiting for components or config changes');
                }
                const tokensCss = "/* This css file contains your color variables, sometimes these get desynced when updated in Framer so it's good that you copy and paste this snippet into your app css */\n" +
                    '/* Bug: https://www.framer.community/c/bugs/color-style-unlinks-when-copying-component-between-projects-resulting-in-potential-value-discrepancy */\n' +
                    getTokensCss({ out, result });
                fs_1.default.writeFileSync(path_1.default.resolve(out, 'tokens.css'), tokensCss, 'utf-8');
            });
        }
        if (!watch) {
            yield rebuild();
            yield buildContext.dispose();
            return;
        }
        // when user press ctrl+c dispose
        process.on('SIGINT', () => __awaiter(this, void 0, void 0, function* () {
            yield buildContext.cancel();
            buildContext.dispose();
        }));
        process.on('SIGABRT', () => __awaiter(this, void 0, void 0, function* () {
            yield buildContext.cancel();
            buildContext.dispose();
        }));
        signal === null || signal === void 0 ? void 0 : signal.addEventListener('abort', () => __awaiter(this, void 0, void 0, function* () {
            yield buildContext.cancel();
            buildContext.dispose();
        }));
        yield rebuild();
        /**
         * Get resolved URLs for all components and also wait for 1 second if it took less time than that
         */
        const getResolvedUrls = () => Promise.all([
            ...Object.values(components).map((u) => {
                const url = new URL(u);
                url.searchParams.set('ts', Date.now().toString());
                return (0, esbuild_2.resolveRedirect)({ url: url.toString(), signal });
            }),
            new Promise((res) => setTimeout(res, 5000)),
        ]);
        let prevUrls = yield getResolvedUrls();
        while (!(signal === null || signal === void 0 ? void 0 : signal.aborted)) {
            const urls = yield getResolvedUrls();
            const changed = urls
                .map((x, i) => (x !== prevUrls[i] ? i : null))
                .filter(Boolean);
            if (!(changed === null || changed === void 0 ? void 0 : changed.length)) {
                continue;
            }
            const changedNames = Object.keys(components).filter((_, i) => changed.includes(i));
            utils_js_1.logger.log(`found new component URLs for ${changedNames.join(', ')}`);
            prevUrls = urls;
            yield rebuild();
        }
    });
}
exports.bundle = bundle;
function decapitalize(str) {
    return str.charAt(0).toLowerCase() + str.slice(1);
}
function findRelativeLinks(text) {
    const regex = /webPageId:\s+/g;
    const lines = text.split('\n');
    const lineNumbers = new Set();
    for (let i = 0; i < lines.length; i++) {
        if (regex.test(lines[i])) {
            lineNumbers.add(i);
        }
    }
    return [...lineNumbers];
}
exports.findRelativeLinks = findRelativeLinks;
function extractPropControlsSafe(text, name) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const propControlsCode = yield parsePropertyControls(text);
            // console.log('propControlsCode', propControlsCode)
            const propControls = yield Promise.resolve().then(() => __awaiter(this, void 0, void 0, function* () {
                if (!propControlsCode)
                    return;
                const ivm = require('isolated-vm');
                const vm = new ivm.Isolate({ memoryLimit: 128 });
                const context = vm.createContextSync();
                const jail = context.global;
                let result = undefined;
                context.global.setSync('__return', (x) => {
                    result = x;
                });
                const mod = vm.compileModuleSync(`${text}`);
                yield mod.instantiateSync(context, (spec, mod) => {
                    // TODO instantiate framer, react, framer-motion etc
                    return;
                });
                yield mod.evaluate({});
                return result;
            }));
            if (!propControls) {
                utils_js_1.logger.error(`no property controls found for component ${name}`);
                return;
            }
            return propControls;
        }
        catch (e) {
            utils_js_1.logger.error(`Cannot get property controls for ${name}`, e.stack);
        }
    });
}
exports.extractPropControlsSafe = extractPropControlsSafe;
function getTokensCss({ out, result, }) {
    var _a, _b, _c;
    const allTokens = [];
    for (let file of result.outputFiles) {
        const code = fs_1.default.readFileSync(path_1.default.resolve(out, file.path), 'utf-8');
        const tokens = extractTokenInfo(code);
        // console.log('tokens', tokens)
        for (let token of tokens) {
            const already = allTokens.find((x) => x.tokenName === token.tokenName);
            const filePath = path_1.default.relative(out, file.path);
            const filePaths = (() => {
                if (!filePath.startsWith('chunk-')) {
                    return [filePath];
                }
                const files = Object.entries(result.metafile.outputs).filter(([k, v]) => {
                    const filename = path_1.default.basename(k);
                    if (filename.startsWith('chunk-')) {
                        return false;
                    }
                    const doesItImport = v.imports.find((x) => x.path === filePath);
                    return doesItImport;
                });
                return files.map(([k, v]) => k);
            })();
            if (!((_a = token === null || token === void 0 ? void 0 : token.tokenName) === null || _a === void 0 ? void 0 : _a.startsWith('--token'))) {
                continue;
            }
            if (!already) {
                allTokens.push({
                    tokenName: token.tokenName,
                    defaultValues: new Set([token.defaultValue]),
                    nameAnnotation: (_b = token.metadata) === null || _b === void 0 ? void 0 : _b.name,
                    usedBy: new Set([...filePaths]),
                });
            }
            else {
                already.defaultValues.add(token.defaultValue);
                if (!already.nameAnnotation && ((_c = token.metadata) === null || _c === void 0 ? void 0 : _c.name)) {
                    already.nameAnnotation = token.metadata.name;
                }
                filePaths.map((x) => already.usedBy.add(x));
            }
        }
    }
    const groupedByUsers = (0, css_js_1.groupBy)(allTokens, (x) => {
        const str = `/* Used by ${[...x.usedBy].sort().join(', ')} */`;
        return str;
    });
    const cssStrings = [...groupedByUsers.entries()]
        .map(([usedBy, x]) => {
        return (`    /* Used by ${[...x[0].usedBy].sort().join(', ')} */\n` +
            [...x]
                .map((x) => {
                const possibleValues = [...x.defaultValues].sort();
                let comment = '';
                comment += x.nameAnnotation
                    ? ` Named as ${JSON.stringify(x.nameAnnotation)} in Framer.`
                    : '';
                comment +=
                    possibleValues.length > 1
                        ? ` Also seen as ${possibleValues
                            .slice(1)
                            .join(', ')}.`
                        : '';
                return `    ${x.tokenName}: ${possibleValues[0]}; ${comment ? `/*${comment} */` : ''}`;
            })
                .join('\n'));
    })
        .join('\n');
    const tokensCss = `:root {\n${cssStrings}\n}`;
    return tokensCss;
}
function extractPropControlsUnsafe(filename, name) {
    return __awaiter(this, void 0, void 0, function* () {
        const delimiter = '__delimiter__';
        let propCode = `JSON.stringify({propertyControls: x.default?.propertyControls, fonts: x?.default?.fonts } || {}, null, 2)`;
        const nodePath = process.execPath || 'node';
        const fileUrl = url_1.default.pathToFileURL(filename).href;
        const code = `import(${JSON.stringify(fileUrl)}).then(x => { console.log(${JSON.stringify(delimiter)}); console.log(${propCode}) })`;
        let stdout = yield new Promise((res, rej) => (0, child_process_1.exec)(`${JSON.stringify(nodePath)} --input-type=module -e ${JSON.stringify(code)}`, (err, stdout) => {
            if (err) {
                return rej(err);
            }
            res(stdout);
        }));
        stdout = stdout.split(delimiter)[1];
        // console.log(stdout)
        return safeJsonParse(stdout);
    });
}
exports.extractPropControlsUnsafe = extractPropControlsUnsafe;
function safeJsonParse(text) {
    try {
        return JSON.parse(text);
    }
    catch (e) {
        utils_js_1.logger.error('cannot parse json', text.slice(0, 100));
        return null;
    }
}
function propControlsToType(controls, fileName) {
    try {
        const types = Object.entries(controls || {})
            .map(([key, value]) => {
            if (!value) {
                return;
            }
            const typescriptType = (value) => {
                value.type;
                switch (value.type) {
                    case framer_1.ControlType.Color:
                        return 'string';
                    case framer_1.ControlType.Boolean:
                        return 'boolean';
                    case framer_1.ControlType.Number:
                        return 'number';
                    case framer_1.ControlType.String:
                        return 'string';
                    case framer_1.ControlType.Enum: {
                        // @ts-expect-error
                        const options = value.optionTitles || value.options;
                        return options.map((x) => `'${x}'`).join(' | ');
                    }
                    case framer_1.ControlType.File:
                        return 'string';
                    case framer_1.ControlType.Image:
                        return 'string';
                    case framer_1.ControlType.ComponentInstance:
                        return 'React.ReactNode';
                    case framer_1.ControlType.Array:
                        // @ts-expect-error
                        return `${typescriptType(value.control)}[]`;
                    case framer_1.ControlType.Object:
                        // @ts-expect-error
                        return `{${Object.entries(value.controls)
                            .map(([k, v]) => {
                            // @ts-expect-error
                            return `${k}: ${typescriptType(v)}`;
                        })
                            .join(', ')}`;
                    case framer_1.ControlType.Date:
                        return 'string | Date';
                    case framer_1.ControlType.Link:
                        return 'string';
                    case framer_1.ControlType.ResponsiveImage:
                        return `{src: string, srcSet?: string, alt?: string}`;
                    case framer_1.ControlType.FusedNumber:
                        return 'number';
                    case framer_1.ControlType.Transition:
                        return 'any';
                    case framer_1.ControlType.EventHandler:
                        return 'Function';
                }
            };
            let name = decapitalize(value.title || key || '');
            if (!name) {
                return '';
            }
            return `    ${JSON.stringify(name)}?: ${typescriptType(value)}`;
        })
            .filter(Boolean)
            .join('\n');
        const componentName = componentCamelCase(fileName === null || fileName === void 0 ? void 0 : fileName.replace(/\.js$/, ''));
        const defaultPropsTypes = [
            'children?: React.ReactNode',
            'style?: React.CSSProperties',
            'className?: string',
            'id?: string',
            'width?: any',
            'height?: any',
            'layoutId?: string',
        ]
            .map((line) => `    ${line}`)
            .join('\n') + '\n';
        let t = '';
        t += 'import * as React from "react"\n\n';
        t += 'import { UnframerBreakpoint } from "unframer"\n\n';
        t += `export interface Props {\n${defaultPropsTypes}${types}\n}\n\n`;
        t += `const ${componentName} = (props: Props) => any\n\n`;
        t += `type VariantsMap = Partial<Record<UnframerBreakpoint, Props['variant']>> & { base: Props['variant'] }\n\n`;
        t += `${componentName}.Responsive = (props: Omit<Props, 'variant'> & {variants: VariantsMap}) => any\n\n`;
        t += `export default ${componentName}\n\n`;
        return t;
    }
    catch (e) {
        utils_js_1.logger.error('cannot generate types', e.stack);
        return '';
    }
}
exports.propControlsToType = propControlsToType;
function parsePropertyControls(code) {
    const start = code.indexOf('addPropertyControls(');
    if (start === -1) {
        utils_js_1.logger.error('no addPropertyControls call found');
        return null;
    }
    // count all parentheses to find when the addPropertyControls ends
    let openParentheses = 0;
    let closedParentheses = 0;
    let current = start;
    // parses using parentheses
    while (current < code.length) {
        const newP = code.indexOf('(', current);
        const newC = code.indexOf(')', current);
        if (newP === -1 && newC === -1) {
            break;
        }
        if (newP !== -1 && newP < newC) {
            openParentheses++;
            current = newP + 1;
        }
        if (newC !== -1 && newC < newP) {
            closedParentheses++;
            current = newC + 1;
        }
        if (openParentheses === closedParentheses) {
            break;
        }
    }
    const end = current;
    const propControls = code.substring(start, end);
    const realStart = propControls.indexOf(',');
    if (realStart === -1) {
        return '';
    }
    return propControls.slice(realStart + 1, -1);
}
exports.parsePropertyControls = parsePropertyControls;
function extractTokenInfo(code) {
    const lines = code.split('\n');
    const tokenLines = lines.filter((line) => line.includes('var(--token'));
    const tokens = [];
    for (const line of tokenLines) {
        let startIndex = 0;
        while (startIndex < line.length) {
            startIndex = line.indexOf('var(--', startIndex);
            if (startIndex === -1) {
                break;
            }
            let parCount = 0;
            let varStatement = '';
            for (let i = startIndex + 3; i < line.length; i++) {
                if (line[i] === '(') {
                    parCount++;
                }
                else if (line[i] === ')') {
                    parCount--;
                }
                varStatement += line[i];
                if (parCount === 0) {
                    break;
                }
            }
            varStatement = varStatement.trim().slice(1).slice(0, -1); // Remove starting and closing parenthesis
            const [tokenName, defaultValue] = splitOnce(varStatement, ',');
            let metadata;
            const jsonStartIndex = line.indexOf('/*', startIndex);
            if (jsonStartIndex !== -1) {
                const jsonEndIndex = line.indexOf('*/', jsonStartIndex);
                if (jsonEndIndex !== -1) {
                    const jsonString = line
                        .slice(jsonStartIndex + 2, jsonEndIndex)
                        .trim();
                    try {
                        metadata = JSON.parse(jsonString);
                    }
                    catch (error) {
                        // console.warn('Failed to parse JSON metadata:', error)
                    }
                }
            }
            if (tokenName && defaultValue) {
                tokens.push({
                    tokenName,
                    defaultValue: defaultValue.trim(),
                    metadata,
                });
            }
            startIndex += varStatement.length + 'var(--'.length; // Move the startIndex to the end of the current var(--token)
        }
    }
    return tokens;
}
exports.extractTokenInfo = extractTokenInfo;
function splitOnce(str, separator) {
    const index = str.indexOf(separator);
    if (index === -1) {
        return [str];
    }
    return [str.slice(0, index), str.slice(index + 1)];
}
function componentCamelCase(str) {
    if (!str) {
        return 'FramerComponent';
    }
    str = str.replace(/-([\w])/g, (g) => g[1].toUpperCase());
    str = str.replace(/_([a-z])/g, (g) => g[1].toUpperCase());
    str = str[0].toUpperCase() + str.slice(1);
    str = str + 'FramerComponent';
    return str;
}
exports.componentCamelCase = componentCamelCase;
//# sourceMappingURL=exporter.js.map