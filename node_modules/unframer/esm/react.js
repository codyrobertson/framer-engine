'use client';
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { combinedCSSRules } from './framer';
import { forwardRef, useId, useMemo, useSyncExternalStore, } from 'react';
import { breakpointsStyles, defaultBreakpointSizes, getFontsStyles, } from './css.js';
function classNames(...args) {
    return args.filter(Boolean).join(' ');
}
// breakpoints from the higher to the lower
const defaultBreakpoints = Object.keys(defaultBreakpointSizes).reverse();
function getBreakpointNameFromWindowWidth(windowWidth) {
    return defaultBreakpoints.find((name) => windowWidth >= defaultBreakpointSizes[name]);
}
function fillBreakpoints(breakpoints) {
    const breakpointsOrder = ['base', 'sm', 'md', 'lg', 'xl', '2xl'];
    const filledBreakpoints = Object.assign({}, breakpoints);
    for (let i = 1; i < breakpointsOrder.length; i++) {
        const currentBreakpoint = breakpointsOrder[i];
        const previousBreakpoint = breakpointsOrder[i - 1];
        if (!filledBreakpoints[currentBreakpoint]) {
            filledBreakpoints[currentBreakpoint] =
                filledBreakpoints[previousBreakpoint];
        }
    }
    return filledBreakpoints;
}
const nothing = () => {
    return () => { };
};
/**
 * @deprecated Use styles.css import instead
 */
export function FramerStyles({ Components = [] }) {
    const isClient = useSyncExternalStore(nothing, () => true, () => false);
    const breakpoints = (_jsx("style", { dangerouslySetInnerHTML: {
            __html: breakpointsStyles(defaultBreakpointSizes),
        }, suppressHydrationWarning: true, hidden: true }, 'breakpointsStyles'));
    const fonts = (_jsx("style", { dangerouslySetInnerHTML: {
            __html: getFontsStyles(Components.map((x) => x.fonts || []).flat()),
        }, suppressHydrationWarning: true, hidden: true }, 'fonts'));
    // if (isClient) {
    //     // on client framer injects the styles by itself
    //     return (
    //         <>
    //             {breakpoints}
    //             {fonts}
    //         </>
    //     )
    // }
    return (_jsxs(_Fragment, { children: [breakpoints, fonts, _jsx("style", { dangerouslySetInnerHTML: {
                    __html: combinedCSSRules.join('\n'),
                }, suppressHydrationWarning: true, hidden: true }, 'combinedCSSRules')] }));
}
export const WithFramerBreakpoints = forwardRef(function WithFramerBreakpoints(_a, ref) {
    var { Component, variants: _breakpointsMap } = _a, rest = __rest(_a, ["Component", "variants"]);
    const id = useId();
    const currentBreakpoint = useSyncExternalStore(onResize, () => {
        // console.log('window.innerWidth', window.innerWidth)
        const breakpoint = getBreakpointNameFromWindowWidth(window.innerWidth);
        return breakpoint;
    }, () => {
        // on server and during hydration
        return '';
    });
    const parts = useMemo(() => {
        var _a;
        const allBreakpoints = fillBreakpoints(_breakpointsMap);
        const variants = {};
        for (let breakpointName of Object.keys(allBreakpoints)) {
            const realVariant = allBreakpoints[breakpointName];
            if (!realVariant) {
                continue;
            }
            if (currentBreakpoint && currentBreakpoint !== breakpointName) {
                continue;
            }
            let className = classNames(((_a = variants[realVariant]) === null || _a === void 0 ? void 0 : _a.className) || 'unframer-hidden', `unframer-${breakpointName}`);
            variants[realVariant] = { className, variant: realVariant };
        }
        return Object.values(variants).map(({ className, variant }) => {
            return (_jsx("div", { className: className, children: _jsx(Component, Object.assign({ ref: ref, 
                    // LayoutGroup is used internally
                    layoutId: id + variant }, rest, { variant: variant }), variant) }, variant));
        });
    }, [currentBreakpoint, rest, _breakpointsMap]);
    return parts;
});
const onResize = (callback) => {
    window.addEventListener('resize', callback);
    return () => window.removeEventListener('resize', callback);
};
//# sourceMappingURL=react.js.map