"use strict";
'use client';
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WithFramerBreakpoints = exports.FramerStyles = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const framer_1 = require("./framer");
const react_1 = require("react");
const css_js_1 = require("./css.js");
function classNames(...args) {
    return args.filter(Boolean).join(' ');
}
// breakpoints from the higher to the lower
const defaultBreakpoints = Object.keys(css_js_1.defaultBreakpointSizes).reverse();
function getBreakpointNameFromWindowWidth(windowWidth) {
    return defaultBreakpoints.find((name) => windowWidth >= css_js_1.defaultBreakpointSizes[name]);
}
function fillBreakpoints(breakpoints) {
    const breakpointsOrder = ['base', 'sm', 'md', 'lg', 'xl', '2xl'];
    const filledBreakpoints = Object.assign({}, breakpoints);
    for (let i = 1; i < breakpointsOrder.length; i++) {
        const currentBreakpoint = breakpointsOrder[i];
        const previousBreakpoint = breakpointsOrder[i - 1];
        if (!filledBreakpoints[currentBreakpoint]) {
            filledBreakpoints[currentBreakpoint] =
                filledBreakpoints[previousBreakpoint];
        }
    }
    return filledBreakpoints;
}
const nothing = () => {
    return () => { };
};
/**
 * @deprecated Use styles.css import instead
 */
function FramerStyles({ Components = [] }) {
    const isClient = (0, react_1.useSyncExternalStore)(nothing, () => true, () => false);
    const breakpoints = ((0, jsx_runtime_1.jsx)("style", { dangerouslySetInnerHTML: {
            __html: (0, css_js_1.breakpointsStyles)(css_js_1.defaultBreakpointSizes),
        }, suppressHydrationWarning: true, hidden: true }, 'breakpointsStyles'));
    const fonts = ((0, jsx_runtime_1.jsx)("style", { dangerouslySetInnerHTML: {
            __html: (0, css_js_1.getFontsStyles)(Components.map((x) => x.fonts || []).flat()),
        }, suppressHydrationWarning: true, hidden: true }, 'fonts'));
    // if (isClient) {
    //     // on client framer injects the styles by itself
    //     return (
    //         <>
    //             {breakpoints}
    //             {fonts}
    //         </>
    //     )
    // }
    return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [breakpoints, fonts, (0, jsx_runtime_1.jsx)("style", { dangerouslySetInnerHTML: {
                    __html: framer_1.combinedCSSRules.join('\n'),
                }, suppressHydrationWarning: true, hidden: true }, 'combinedCSSRules')] }));
}
exports.FramerStyles = FramerStyles;
exports.WithFramerBreakpoints = (0, react_1.forwardRef)(function WithFramerBreakpoints(_a, ref) {
    var { Component, variants: _breakpointsMap } = _a, rest = __rest(_a, ["Component", "variants"]);
    const id = (0, react_1.useId)();
    const currentBreakpoint = (0, react_1.useSyncExternalStore)(onResize, () => {
        // console.log('window.innerWidth', window.innerWidth)
        const breakpoint = getBreakpointNameFromWindowWidth(window.innerWidth);
        return breakpoint;
    }, () => {
        // on server and during hydration
        return '';
    });
    const parts = (0, react_1.useMemo)(() => {
        var _a;
        const allBreakpoints = fillBreakpoints(_breakpointsMap);
        const variants = {};
        for (let breakpointName of Object.keys(allBreakpoints)) {
            const realVariant = allBreakpoints[breakpointName];
            if (!realVariant) {
                continue;
            }
            if (currentBreakpoint && currentBreakpoint !== breakpointName) {
                continue;
            }
            let className = classNames(((_a = variants[realVariant]) === null || _a === void 0 ? void 0 : _a.className) || 'unframer-hidden', `unframer-${breakpointName}`);
            variants[realVariant] = { className, variant: realVariant };
        }
        return Object.values(variants).map(({ className, variant }) => {
            return ((0, jsx_runtime_1.jsx)("div", { className: className, children: (0, jsx_runtime_1.jsx)(Component, Object.assign({ ref: ref, 
                    // LayoutGroup is used internally
                    layoutId: id + variant }, rest, { variant: variant }), variant) }, variant));
        });
    }, [currentBreakpoint, rest, _breakpointsMap]);
    return parts;
});
const onResize = (callback) => {
    window.addEventListener('resize', callback);
    return () => window.removeEventListener('resize', callback);
};
//# sourceMappingURL=react.js.map