"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.groupBy = exports.breakpointsStyles = exports.defaultBreakpointSizes = exports.getFontsStyles = exports.logFontsUsage = void 0;
const dedent_1 = __importDefault(require("dedent"));
function deduplicateByKey(arr, key) {
    let map = new Map();
    for (let item of arr) {
        let value = key(item);
        if (map.has(value)) {
            continue;
        }
        map.set(value, item);
    }
    return Array.from(map.values());
}
function logFontsUsage(fontsBundles) {
    if (!fontsBundles.length) {
        return '';
    }
    let familyToFilenames = new Map();
    for (let fontDefBundle of fontsBundles) {
        let filename = fontDefBundle.fileName;
        for (let font of fontDefBundle.fonts) {
            if (familyToFilenames.has(font.family)) {
                familyToFilenames.get(font.family).add(filename);
            }
            else {
                familyToFilenames.set(font.family, new Set([filename]));
            }
        }
    }
    let str = `There are ${familyToFilenames.size} fonts used:\n`;
    for (let [family, filenames] of familyToFilenames.entries()) {
        str += `${JSON.stringify(family)}, used by\n`;
        for (let filename of filenames) {
            str += `  - ${filename}\n`;
        }
    }
    return str;
}
exports.logFontsUsage = logFontsUsage;
function getFontsStyles(_fontsDefs) {
    if (!_fontsDefs.length) {
        return '';
    }
    let urlToFilenames = new Map();
    for (let fontDefBundle of _fontsDefs) {
        let filename = fontDefBundle.fileName;
        for (let font of fontDefBundle.fonts) {
            if (urlToFilenames.has(font.url)) {
                urlToFilenames.get(font.url).add(filename);
            }
            else {
                urlToFilenames.set(font.url, new Set([filename]));
            }
        }
    }
    const allFonts = deduplicateByKey(_fontsDefs.flatMap((x) => x.fonts), (x) => x === null || x === void 0 ? void 0 : x.url)
        .filter((x) => x.url)
        .sort((a, b) => a.url.localeCompare(b.url));
    // group fonts by the filenames users
    const grouped = groupBy(allFonts, (x) => {
        return [...(urlToFilenames.get(x.url) || [])].sort().join(', ');
    });
    let str = '\n\n';
    for (let [groupComment, fonts] of grouped.entries()) {
        fonts = sortByKey(fonts, (x) => x.url);
        str += `/* used by ${groupComment} */\n`;
        str +=
            '\n' +
                fonts
                    .map((x) => {
                    let str = '';
                    str += (0, dedent_1.default) `
                    @font-face {
                        font-family: '${x.family}'; 
                        src: url(${x.url});\n`;
                    if (x.style) {
                        str += `    font-style: ${x.style};\n`;
                    }
                    if (x.weight) {
                        str += `    font-weight: ${x.weight};\n`;
                    }
                    if (x.unicodeRange) {
                        str += `    unicodeRange: ${x.unicodeRange};\n`;
                    }
                    str += `}\n`;
                    return str;
                })
                    .join('\n') +
                '\n';
    }
    return str;
}
exports.getFontsStyles = getFontsStyles;
exports.defaultBreakpointSizes = {
    base: 0,
    sm: 320,
    md: 768,
    lg: 960,
    xl: 1200,
    '2xl': 1536,
};
const breakpointsStyles = (breakpointSizes) => {
    breakpointSizes = Object.assign(Object.assign({}, exports.defaultBreakpointSizes), breakpointSizes);
    return /* css */ `
/* Base */
@media (min-width: ${breakpointSizes.base}px) and (max-width: ${breakpointSizes.sm - 1}px) {
    .unframer-hidden.unframer-base { 
        display: contents;
    }
}

/* Small */
@media (min-width: ${breakpointSizes.sm}px) and (max-width: ${breakpointSizes.md - 1}px) {
    .unframer-hidden.unframer-sm { 
        display: contents;
    }
}

/* Medium */
@media (min-width: ${breakpointSizes.md}px) and (max-width: ${breakpointSizes.lg - 1}px) {
    .unframer-hidden.unframer-md { 
        display: contents;
    }
}

/* Large */
@media (min-width: ${breakpointSizes.lg}px) and (max-width: ${breakpointSizes.xl - 1}px) {
    .unframer-hidden.unframer-lg { 
        display: contents;
    }
}

/* Extra Large */
@media (min-width: ${breakpointSizes.xl}px) and (max-width: ${breakpointSizes['2xl'] - 1}px) {
    .unframer-hidden.unframer-xl { 
        display: contents;
    }
}

/* 2 Extra Large */
@media (min-width: ${breakpointSizes['2xl']}px) {
    .unframer-hidden.unframer-2xl { 
        display: contents;
    }
}

.unframer-hidden {
    display: none;
}
`;
};
exports.breakpointsStyles = breakpointsStyles;
function groupBy(arr, key) {
    var _a;
    const map = new Map();
    for (let item of arr) {
        const k = key(item);
        if (!map.has(k)) {
            map.set(k, []);
        }
        (_a = map.get(k)) === null || _a === void 0 ? void 0 : _a.push(item);
    }
    return map;
}
exports.groupBy = groupBy;
function sortByKey(arr, key) {
    return arr.slice().sort((a, b) => key(a).localeCompare(key(b)));
}
//# sourceMappingURL=css.js.map